<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta
            name="description"
            content="Visualization of Zipfian distribution and DeepSeek Engram cache hierarchy for LLM inference"
        />
        <meta name="theme-color" content="#1428a0" />
        <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png" />
        <link rel="icon" type="image/png" sizes="512x512" href="icon-512.png" />
        <title>Zipfian Distribution & Engram Cache Hierarchy</title>
        <style>
            :root {
                --primary-blue: #1428a0;
                --light-blue: #5fa3e6;
                --accent-purple: #7c3aed;
                --accent-cyan: #64ffda;
                --accent-pink: #f472b6;
                --accent-green: #22c55e;
                --accent-yellow: #fbbf24;
                --dark-bg: #0a0a0f;
                --surface: rgba(255, 255, 255, 0.03);
                --border: #333;
                --text-primary: #e8e6e3;
                --text-secondary: #888;
                --text-muted: #666;
            }

            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family: 'IBM Plex Mono', 'Fira Code', monospace;
                background: var(--dark-bg);
                color: var(--text-primary);
                min-height: 100vh;
                padding: 2rem;
            }

            /* Background pattern */
            .bg-pattern {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-image:
                    radial-gradient(circle at 25% 25%, rgba(124, 58, 237, 0.03) 0%, transparent 50%),
                    radial-gradient(circle at 75% 75%, rgba(100, 255, 218, 0.03) 0%, transparent 50%);
                pointer-events: none;
                z-index: 0;
            }

            .container {
                position: relative;
                z-index: 1;
                max-width: 1400px;
                margin: 0 auto;
            }

            /* Header */
            .header {
                text-align: center;
                margin-bottom: 2rem;
            }

            h1 {
                font-size: 2.2rem;
                font-weight: 300;
                letter-spacing: 0.15em;
                background: linear-gradient(90deg, var(--accent-pink), var(--accent-purple), var(--accent-cyan));
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                background-clip: text;
                margin-bottom: 0.5rem;
            }

            .subtitle {
                color: var(--text-secondary);
                font-size: 0.95rem;
                max-width: 800px;
                margin: 0 auto;
            }

            .quote-source {
                color: var(--text-muted);
                font-size: 0.8rem;
                font-style: italic;
                margin-top: 0.5rem;
            }

            /* Tab Navigation */
            .tab-nav {
                display: flex;
                justify-content: center;
                gap: 0.5rem;
                margin-bottom: 2rem;
                flex-wrap: wrap;
            }

            .tab-btn {
                padding: 0.6rem 1.2rem;
                border: 1px solid var(--border);
                background: transparent;
                color: var(--text-secondary);
                cursor: pointer;
                font-size: 0.85rem;
                border-radius: 4px;
                transition: all 0.2s ease;
                font-family: inherit;
            }

            .tab-btn:hover {
                color: var(--text-primary);
                border-color: var(--accent-purple);
            }

            .tab-btn.active {
                border-color: var(--accent-purple);
                background: linear-gradient(135deg, rgba(124, 58, 237, 0.2), rgba(100, 255, 218, 0.1));
                color: var(--accent-cyan);
            }

            /* Controls Panel */
            .controls-panel {
                background: var(--surface);
                border: 1px solid var(--border);
                border-radius: 12px;
                padding: 1.5rem;
                margin-bottom: 2rem;
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
                gap: 1.5rem;
            }

            .control-group label {
                display: block;
                font-size: 0.85rem;
                margin-bottom: 0.5rem;
            }

            .control-group input[type='range'] {
                width: 100%;
                accent-color: var(--accent-purple);
            }

            .control-hint {
                color: var(--text-muted);
                font-size: 0.75rem;
                margin-top: 0.25rem;
            }

            .control-hint .from-paper {
                color: var(--accent-green);
            }

            .control-hint .estimate {
                color: var(--accent-pink);
            }

            /* Content Area */
            .content {
                background: rgba(0, 0, 0, 0.3);
                border: 1px solid var(--border);
                border-radius: 12px;
                padding: 2rem;
                min-height: 500px;
            }

            .tab-panel {
                display: none;
            }

            .tab-panel.active {
                display: block;
            }

            .tab-panel h2 {
                color: var(--accent-pink);
                margin-bottom: 1.5rem;
                font-weight: 400;
            }

            .tab-panel h3 {
                color: var(--accent-cyan);
                font-size: 0.95rem;
                margin-bottom: 1rem;
            }

            /* Grid layouts */
            .grid-2 {
                display: grid;
                grid-template-columns: 2fr 1fr;
                gap: 2rem;
            }

            .grid-2-equal {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 2rem;
            }

            .grid-3 {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 1rem;
            }

            /* Info boxes */
            .info-box {
                border-radius: 8px;
                padding: 1rem;
                margin-bottom: 1rem;
            }

            .info-box.purple {
                background: rgba(124, 58, 237, 0.1);
                border: 1px solid rgba(124, 58, 237, 0.3);
            }

            .info-box.green {
                background: rgba(34, 197, 94, 0.1);
                border: 1px solid rgba(34, 197, 94, 0.3);
            }

            .info-box.yellow {
                background: rgba(251, 191, 36, 0.1);
                border: 1px solid rgba(251, 191, 36, 0.3);
            }

            .info-box.pink {
                background: rgba(244, 114, 182, 0.1);
                border: 1px solid rgba(244, 114, 182, 0.3);
            }

            .info-box.cyan {
                background: rgba(100, 255, 218, 0.1);
                border: 1px solid rgba(100, 255, 218, 0.3);
            }

            .info-box h4 {
                margin: 0 0 0.75rem 0;
                font-size: 0.95rem;
            }

            .info-box p {
                margin: 0;
                font-size: 0.85rem;
                line-height: 1.6;
                color: var(--text-secondary);
            }

            .info-box ul {
                margin: 0.5rem 0 0 0;
                padding-left: 1.2rem;
                font-size: 0.85rem;
                line-height: 1.8;
                color: var(--text-secondary);
            }

            /* N-gram examples table */
            .ngram-row {
                display: flex;
                justify-content: space-between;
                padding: 0.5rem;
                border-radius: 4px;
                font-size: 0.8rem;
            }

            .ngram-row:nth-child(even) {
                background: rgba(255, 255, 255, 0.02);
            }

            .ngram-rank {
                color: var(--text-secondary);
            }

            .ngram-text {
                color: var(--accent-pink);
                font-family: monospace;
            }

            /* Tier stats */
            .tier-card {
                background: rgba(0, 0, 0, 0.3);
                border-radius: 8px;
                padding: 1rem;
                margin-bottom: 1rem;
            }

            .tier-card-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0.5rem;
            }

            .tier-card h4 {
                margin: 0;
            }

            .tier-storage {
                color: var(--text-secondary);
                font-size: 0.8rem;
            }

            .tier-progress {
                height: 8px;
                background: #222;
                border-radius: 4px;
                overflow: hidden;
                margin-top: 0.5rem;
            }

            .tier-progress-bar {
                height: 100%;
                border-radius: 4px;
            }

            /* SVG container */
            .svg-container {
                width: 100%;
            }

            .svg-container svg {
                width: 100%;
                height: auto;
            }

            /* Footer */
            .footer {
                margin-top: 2rem;
                padding: 1.5rem;
                background: var(--surface);
                border-radius: 8px;
                border: 1px solid var(--border);
            }

            .footer-legend {
                display: flex;
                justify-content: center;
                gap: 2rem;
                margin-bottom: 1rem;
                flex-wrap: wrap;
                font-size: 0.8rem;
            }

            .legend-item {
                display: flex;
                align-items: center;
                gap: 0.5rem;
            }

            .legend-dot {
                display: inline-block;
                width: 12px;
                height: 12px;
                border-radius: 2px;
            }

            .footer-text {
                text-align: center;
                color: var(--text-muted);
                font-size: 0.85rem;
            }

            .footer-source {
                color: var(--text-secondary);
                font-size: 0.8rem;
            }

            /* Back link */
            .back-link {
                position: fixed;
                bottom: 20px;
                left: 20px;
                font-size: 0.8em;
                z-index: 10;
            }

            .back-link a {
                color: rgba(95, 163, 230, 0.7);
                text-decoration: none;
                transition: color 0.3s;
            }

            .back-link a:hover {
                color: var(--light-blue);
            }

            /* Responsive */
            @media (max-width: 900px) {
                body {
                    padding: 1rem;
                }

                h1 {
                    font-size: 1.5rem;
                }

                .grid-2,
                .grid-2-equal {
                    grid-template-columns: 1fr;
                }

                .grid-3 {
                    grid-template-columns: 1fr;
                }

                .content {
                    padding: 1rem;
                }
            }
        </style>
    </head>
    <body>
        <div class="bg-pattern"></div>

        <div class="container">
            <div class="header">
                <h1>Zipfian Distribution & Engram Cache Hierarchy</h1>
                <p class="subtitle">
                    "Natural language N-grams inherently follow a Zipfian distribution, where a small fraction of
                    patterns accounts for the vast majority of memory accesses."
                </p>
                <p class="quote-source">‚Äî DeepSeek Engram Paper (2026), citing Chao & Zipf (1950), Piantadosi (2014)</p>
            </div>

            <div class="tab-nav">
                <button class="tab-btn active" data-tab="distribution">Zipf's Law</button>
                <button class="tab-btn" data-tab="multihash">Multi-Head Hashing</button>
                <button class="tab-btn" data-tab="loglog">Log-Log Plot</button>
                <button class="tab-btn" data-tab="tiers">Cache Hierarchy</button>
                <button class="tab-btn" data-tab="engram">Engram Architecture</button>
            </div>

            <div class="controls-panel">
                <div class="control-group">
                    <label style="color: var(--accent-cyan)">
                        Zipf Exponent (s):
                        <span id="zipfValue">1.00</span>
                    </label>
                    <input type="range" id="zipfSlider" min="0.5" max="1.5" step="0.05" value="1.0" />
                    <p class="control-hint">
                        <span class="estimate">*Estimate:</span>
                        Natural language &asymp; 1.0 (paper cites Zipf but doesn't specify s)
                    </p>
                </div>

                <div class="control-group">
                    <label style="color: var(--accent-cyan)">
                        N-gram Vocabulary:
                        <span id="vocabValue">2.3</span>
                        M entries
                    </label>
                    <input type="range" id="vocabSlider" min="1000000" max="10000000" step="100000" value="2300000" />
                    <p class="control-hint">
                        <span class="from-paper">From paper:</span>
                        Engram-27B = 5.7B params &divide; 2.5KB &asymp; 2.3M entries
                    </p>
                </div>

                <div class="control-group">
                    <label style="color: var(--accent-green)">
                        GPU HBM Tier:
                        <span id="gpuTierValue">1</span>
                        % of entries
                    </label>
                    <input type="range" id="gpuTierSlider" min="0.1" max="5" step="0.1" value="1" />
                    <p class="control-hint">
                        <span class="estimate">*Projection:</span>
                        Paper suggests tiering but doesn't specify ratios
                    </p>
                </div>

                <div class="control-group">
                    <label style="color: var(--accent-yellow)">
                        Host DRAM Tier:
                        <span id="dramTierValue">10</span>
                        % of entries
                    </label>
                    <input type="range" id="dramTierSlider" min="1" max="30" step="1" value="10" />
                    <p class="control-hint">
                        <span class="estimate">*Projection:</span>
                        Actual ratios depend on available memory
                    </p>
                </div>
            </div>

            <div class="content">
                <!-- Zipf's Law Tab -->
                <div id="distribution" class="tab-panel active">
                    <h2>
                        Zipf's Law: f(r) &prop; 1/r
                        <sup>s</sup>
                    </h2>

                    <div class="grid-2">
                        <div class="svg-container">
                            <svg id="zipfChart" viewBox="0 0 600 420"></svg>
                        </div>

                        <div>
                            <h3>Example N-gram Ranks</h3>
                            <div id="ngramExamples"></div>

                            <div class="info-box purple" style="margin-top: 1.5rem">
                                <p>
                                    <strong style="color: var(--accent-purple)">Key Insight:</strong>
                                    Common patterns like "the", "of the", "in the" dominate access frequency. Rare
                                    N-grams may appear once per million tokens.
                                </p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Multi-Head Hashing Tab -->
                <div id="multihash" class="tab-panel">
                    <h2>Multi-Head Hashing: Parallel Lookups & Collision Mitigation</h2>
                    <p style="color: var(--text-secondary); margin-bottom: 1.5rem; font-size: 0.9rem">
                        Engram uses 8 hash heads &times; 2 N-gram orders = 16 independent parallel lookups per token
                        position.
                    </p>

                    <div class="grid-2-equal">
                        <div class="svg-container">
                            <svg id="multihashDiagram" viewBox="0 0 450 500"></svg>
                        </div>

                        <div>
                            <div class="info-box pink">
                                <h4 style="color: var(--accent-pink)">Why Multiple Hash Heads?</h4>
                                <p>
                                    <strong style="color: var(--accent-cyan)">Collision mitigation:</strong>
                                    With a single hash function, two different N-grams might map to the same slot. With
                                    8 independent hash functions pointing to 8 separate tables, the probability that
                                    <em>all 8</em>
                                    collide is near zero.
                                </p>
                                <p style="margin-top: 0.75rem">
                                    The model learns to rely on the heads that didn't collide for any given N-gram.
                                </p>
                            </div>

                            <div class="info-box green">
                                <h4 style="color: var(--accent-green)">Why This Enables Parallelism</h4>
                                <p>All 16 lookups are:</p>
                                <ul>
                                    <li>
                                        <strong style="color: var(--accent-green)">Independent</strong>
                                        ‚Äî no data dependency between them
                                    </li>
                                    <li>
                                        <strong style="color: var(--accent-green)">Deterministic</strong>
                                        ‚Äî computed purely from input tokens
                                    </li>
                                    <li>
                                        <strong style="color: var(--accent-green)">Fixed size</strong>
                                        ‚Äî each returns 80-dim (1280 &divide; 16)
                                    </li>
                                </ul>
                            </div>

                            <div class="info-box purple">
                                <h4 style="color: var(--accent-purple)">Storage Implications</h4>
                                <p>
                                    On
                                    <strong>GPU</strong>
                                    : Single batched gather operation
                                    <br />
                                    On
                                    <strong>SSD</strong>
                                    : 16 parallel io_uring submissions
                                    <br />
                                    On
                                    <strong>tiered storage</strong>
                                    : Some hit GPU, some DRAM, some SSD ‚Äî all in parallel
                                </p>
                            </div>

                            <div class="info-box yellow">
                                <h4 style="color: var(--accent-yellow)">üìä From the Paper</h4>
                                <p>
                                    "We set the maximum N-gram size to
                                    <strong style="color: var(--accent-yellow)">3</strong>
                                    , the number of heads to
                                    <strong style="color: var(--accent-yellow)">8</strong>
                                    , and the dimension to
                                    <strong style="color: var(--accent-yellow)">1280</strong>
                                    ."
                                </p>
                                <p style="margin-top: 0.5rem; font-size: 0.8rem; color: var(--text-muted)">
                                    N-gram orders used: {2, 3} (bigrams and trigrams)
                                </p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Log-Log Plot Tab -->
                <div id="loglog" class="tab-panel">
                    <h2>Log-Log Plot: The Classic Zipf Signature</h2>
                    <p style="color: var(--text-secondary); margin-bottom: 1.5rem; font-size: 0.9rem">
                        Zipfian distributions appear as straight lines on log-log plots. Slope = -s (the Zipf exponent).
                    </p>

                    <div class="svg-container">
                        <svg id="loglogChart" viewBox="0 0 700 400"></svg>
                    </div>

                    <div class="grid-3" style="margin-top: 1.5rem" id="exponentCards"></div>
                </div>

                <!-- Cache Hierarchy Tab -->
                <div id="tiers" class="tab-panel">
                    <h2>Multi-Level Cache Hierarchy</h2>

                    <div class="info-box purple" style="margin-bottom: 1.5rem; font-size: 0.9rem">
                        <p>
                            <strong style="color: var(--accent-purple)">From the paper:</strong>
                            "This statistical property motivates a Multi-Level Cache Hierarchy: frequently accessed
                            embeddings can be cached in faster storage tiers (e.g., GPU HBM or Host DRAM), while the
                            long tail of rare patterns resides in slower, high-capacity media (e.g., NVMe SSD). This
                            stratification allows Engram to scale to massive memory capacities with minimal impact on
                            effective latency."
                        </p>
                    </div>

                    <div class="grid-2-equal">
                        <div class="svg-container">
                            <svg id="tiersDiagram" viewBox="0 0 400 400"></svg>
                        </div>

                        <div>
                            <h3>Access Distribution</h3>
                            <div id="tierStats"></div>

                            <div class="info-box cyan" id="zipfPowerBox"></div>
                        </div>
                    </div>
                </div>

                <!-- Engram Architecture Tab -->
                <div id="engram" class="tab-panel">
                    <h2>Engram: Deterministic Addressing Enables Offload</h2>

                    <div class="grid-2-equal">
                        <div>
                            <h3>Why Offload Works for Engram</h3>

                            <div class="info-box green">
                                <h4 style="color: var(--accent-green)">Deterministic Hash IDs</h4>
                                <p>
                                    "Unlike MoE, which relies on runtime hidden states for dynamic routing, Engram's
                                    retrieval indices depend solely on the input token sequence."
                                </p>
                                <p style="margin-top: 0.75rem; color: var(--accent-cyan)">
                                    &rarr; Hash IDs are known
                                    <strong>before</strong>
                                    the layer executes
                                </p>
                            </div>

                            <div class="info-box yellow">
                                <h4 style="color: var(--accent-yellow)">Prefetch-and-Overlap Strategy</h4>
                                <p>
                                    "The system can asynchronously retrieve embeddings from abundant host memory via
                                    PCIe. To effectively mask communication latency, the Engram module is placed at
                                    specific layers within the backbone, leveraging the computation of preceding layers
                                    as a buffer."
                                </p>
                            </div>

                            <div class="info-box purple">
                                <h4 style="color: var(--accent-purple)">Measured Overhead</h4>
                                <p>
                                    "Offloading a 100B-parameter embedding table incurs a negligible throughput penalty,
                                    peaking at only
                                    <strong style="color: var(--accent-cyan)">2.8%</strong>
                                    on the 8B backbone."
                                </p>
                            </div>
                        </div>

                        <div>
                            <h3>Access Pattern per Token</h3>

                            <div class="svg-container">
                                <svg id="accessPatternDiagram" viewBox="0 0 350 300"></svg>
                            </div>

                            <div
                                style="
                                    margin-top: 1rem;
                                    padding: 1rem;
                                    background: rgba(0, 0, 0, 0.3);
                                    border-radius: 8px;
                                    font-size: 0.85rem;
                                "
                            >
                                <p style="margin: 0 0 0.5rem 0; color: var(--text-secondary)">
                                    <strong style="color: var(--accent-cyan)">Key:</strong>
                                    All 16 hash IDs are computed from input tokens alone ‚Äî no dependency on hidden
                                    states.
                                </p>
                                <p style="margin: 0; color: var(--text-secondary)">
                                    This enables
                                    <strong style="color: var(--accent-green)">prefetching</strong>
                                    from any storage tier while earlier layers compute.
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="footer">
                <div class="footer-legend">
                    <div class="legend-item">
                        <span class="legend-dot" style="background: var(--accent-green)"></span>
                        <span style="color: var(--text-secondary)">From paper (specified values)</span>
                    </div>
                    <div class="legend-item">
                        <span class="legend-dot" style="background: var(--accent-pink)"></span>
                        <span style="color: var(--text-secondary)">Estimate/Projection (not in paper)</span>
                    </div>
                </div>
                <div class="footer-text">
                    <p>
                        Based on "Conditional Memory via Scalable Lookup: A New Axis of Sparsity for Large Language
                        Models"
                    </p>
                    <p class="footer-source">DeepSeek-AI (January 2026) | arXiv:2601.07372</p>
                </div>
            </div>
        </div>

        <div class="back-link">
            <a href="index.html">&larr; Back to KV Cache Visualization</a>
        </div>

        <script>
            // State
            let zipfExponent = 1.0
            let vocabSize = 2300000
            let gpuTierPercent = 1
            let dramTierPercent = 10

            // DOM Elements
            const zipfSlider = document.getElementById('zipfSlider')
            const vocabSlider = document.getElementById('vocabSlider')
            const gpuTierSlider = document.getElementById('gpuTierSlider')
            const dramTierSlider = document.getElementById('dramTierSlider')

            const zipfValue = document.getElementById('zipfValue')
            const vocabValue = document.getElementById('vocabValue')
            const gpuTierValue = document.getElementById('gpuTierValue')
            const dramTierValue = document.getElementById('dramTierValue')

            // Example N-grams
            const exampleNgrams = [
                { rank: 1, ngram: '"the"', freq: 'Very High' },
                { rank: 2, ngram: '"of the"', freq: 'Very High' },
                { rank: 10, ngram: '"United States"', freq: 'High' },
                { rank: 100, ngram: '"machine learning"', freq: 'Medium' },
                { rank: 1000, ngram: '"quantum computing"', freq: 'Low' },
                { rank: 10000, ngram: '"defenestration"', freq: 'Very Low' },
                { rank: 100000, ngram: '"xyzzy plugh"', freq: 'Rare' },
            ]

            // Calculate Zipf distribution data
            function calculateZipfData() {
                const numBars = 100
                const data = []

                // Calculate harmonic number for normalization
                let harmonicSum = 0
                for (let i = 1; i <= vocabSize; i++) {
                    harmonicSum += 1 / Math.pow(i, zipfExponent)
                }

                // Generate distribution data (sampled for visualization)
                let cumulativeFreq = 0
                for (let i = 0; i < numBars; i++) {
                    const rank = Math.floor(Math.pow(10, (i / numBars) * Math.log10(vocabSize))) || 1
                    const frequency = 1 / Math.pow(rank, zipfExponent) / harmonicSum
                    cumulativeFreq +=
                        frequency *
                        (i === 0 ? rank : rank - Math.floor(Math.pow(10, ((i - 1) / numBars) * Math.log10(vocabSize))))

                    data.push({
                        rank,
                        frequency,
                        cumulativePercent: Math.min(cumulativeFreq * 100, 100),
                        logRank: Math.log10(rank),
                        logFreq: Math.log10(frequency),
                    })
                }

                return data
            }

            // Calculate tier statistics
            function calculateTierStats() {
                let harmonicSum = 0
                for (let i = 1; i <= vocabSize; i++) {
                    harmonicSum += 1 / Math.pow(i, zipfExponent)
                }

                const gpuCutoff = Math.floor((vocabSize * gpuTierPercent) / 100)
                const dramCutoff = Math.floor((vocabSize * (gpuTierPercent + dramTierPercent)) / 100)

                let gpuAccess = 0
                let dramAccess = 0
                let ssdAccess = 0

                for (let i = 1; i <= vocabSize; i++) {
                    const freq = 1 / Math.pow(i, zipfExponent) / harmonicSum
                    if (i <= gpuCutoff) {
                        gpuAccess += freq
                    } else if (i <= dramCutoff) {
                        dramAccess += freq
                    } else {
                        ssdAccess += freq
                    }
                }

                // Storage calculations (assuming 2.5KB per embedding: 1280 dim √ó 2 bytes)
                const embeddingSize = 2.5 // KB
                const gpuStorage = (gpuCutoff * embeddingSize) / 1024 // MB
                const dramStorage = ((dramCutoff - gpuCutoff) * embeddingSize) / 1024 // MB
                const ssdStorage = ((vocabSize - dramCutoff) * embeddingSize) / 1024 / 1024 // GB

                return {
                    gpu: {
                        entries: gpuCutoff,
                        accessPercent: gpuAccess * 100,
                        storageMB: gpuStorage,
                    },
                    dram: {
                        entries: dramCutoff - gpuCutoff,
                        accessPercent: dramAccess * 100,
                        storageMB: dramStorage,
                    },
                    ssd: {
                        entries: vocabSize - dramCutoff,
                        accessPercent: ssdAccess * 100,
                        storageGB: ssdStorage,
                    },
                }
            }

            // Tab switching
            document.querySelectorAll('.tab-btn').forEach((btn) => {
                btn.addEventListener('click', () => {
                    const tabId = btn.dataset.tab

                    document.querySelectorAll('.tab-btn').forEach((b) => b.classList.remove('active'))
                    btn.classList.add('active')

                    document.querySelectorAll('.tab-panel').forEach((panel) => {
                        panel.classList.remove('active')
                        if (panel.id === tabId) {
                            panel.classList.add('active')
                        }
                    })
                })
            })

            // Slider event listeners
            zipfSlider.addEventListener('input', (e) => {
                zipfExponent = parseFloat(e.target.value)
                zipfValue.textContent = zipfExponent.toFixed(2)
                updateAll()
            })

            vocabSlider.addEventListener('input', (e) => {
                vocabSize = parseInt(e.target.value)
                vocabValue.textContent = (vocabSize / 1000000).toFixed(1)
                updateAll()
            })

            gpuTierSlider.addEventListener('input', (e) => {
                gpuTierPercent = parseFloat(e.target.value)
                gpuTierValue.textContent = gpuTierPercent.toFixed(1)
                updateAll()
            })

            dramTierSlider.addEventListener('input', (e) => {
                dramTierPercent = parseFloat(e.target.value)
                dramTierValue.textContent = dramTierPercent.toFixed(0)
                updateAll()
            })

            // Render N-gram examples
            function renderNgramExamples() {
                const container = document.getElementById('ngramExamples')
                container.innerHTML = exampleNgrams
                    .map((item) => {
                        const color =
                            item.rank < 100
                                ? 'var(--accent-green)'
                                : item.rank < 10000
                                  ? 'var(--accent-yellow)'
                                  : 'var(--text-secondary)'
                        return `
                        <div class="ngram-row">
                            <span class="ngram-rank">#${item.rank.toLocaleString()}</span>
                            <span class="ngram-text">${item.ngram}</span>
                            <span style="color: ${color}; font-size: 0.7rem">${item.freq}</span>
                        </div>
                    `
                    })
                    .join('')
            }

            // Render Zipf chart
            function renderZipfChart() {
                const svg = document.getElementById('zipfChart')
                const zipfData = calculateZipfData()
                const tierStats = calculateTierStats()

                svg.innerHTML = `
                    <!-- Axes -->
                    <line x1="60" y1="300" x2="580" y2="300" stroke="#444" stroke-width="1"/>
                    <line x1="60" y1="300" x2="60" y2="30" stroke="#444" stroke-width="1"/>

                    <!-- Axis labels -->
                    <text x="320" y="395" text-anchor="middle" fill="#888" font-size="12">
                        Rank (most frequent ‚Üí least frequent)
                    </text>
                    <text x="20" y="165" text-anchor="middle" fill="#888" font-size="12"
                        transform="rotate(-90, 20, 165)">
                        Frequency
                    </text>

                    <!-- Tier backgrounds -->
                    <rect x="60" y="30" width="${(520 * gpuTierPercent) / 100}" height="270"
                        fill="rgba(34, 197, 94, 0.15)"/>
                    <rect x="${60 + (520 * gpuTierPercent) / 100}" y="30"
                        width="${(520 * dramTierPercent) / 100}" height="270"
                        fill="rgba(251, 191, 36, 0.1)"/>
                    <rect x="${60 + (520 * (gpuTierPercent + dramTierPercent)) / 100}" y="30"
                        width="${(520 * (100 - gpuTierPercent - dramTierPercent)) / 100}" height="270"
                        fill="rgba(100, 100, 100, 0.05)"/>

                    <!-- Vertical divider lines -->
                    <line
                        x1="${60 + (520 * gpuTierPercent) / 100}" y1="30"
                        x2="${60 + (520 * gpuTierPercent) / 100}" y2="300"
                        stroke="#22c55e" stroke-width="2" stroke-dasharray="4,4"/>
                    <line
                        x1="${60 + (520 * (gpuTierPercent + dramTierPercent)) / 100}" y1="30"
                        x2="${60 + (520 * (gpuTierPercent + dramTierPercent)) / 100}" y2="300"
                        stroke="#fbbf24" stroke-width="2" stroke-dasharray="4,4"/>

                    <!-- Tier labels -->
                    <line x1="${60 + (520 * gpuTierPercent) / 200}" y1="310"
                        x2="${60 + (520 * gpuTierPercent) / 200}" y2="325" stroke="#22c55e" stroke-width="1"/>
                    <text x="${60 + (520 * gpuTierPercent) / 200}" y="338" text-anchor="middle"
                        fill="#22c55e" font-size="10" font-weight="bold">GPU HBM (${gpuTierPercent}%)</text>
                    <text x="${60 + (520 * gpuTierPercent) / 200}" y="352" text-anchor="middle"
                        fill="#22c55e" font-size="9">${tierStats.gpu.storageMB.toFixed(0)} MB</text>

                    <line x1="${60 + (520 * (gpuTierPercent + dramTierPercent / 2)) / 100}" y1="310"
                        x2="${60 + (520 * (gpuTierPercent + dramTierPercent / 2)) / 100}" y2="355" stroke="#fbbf24" stroke-width="1"/>
                    <text x="${60 + (520 * (gpuTierPercent + dramTierPercent / 2)) / 100}" y="370"
                        text-anchor="middle" fill="#fbbf24" font-size="10" font-weight="bold">Host DRAM (${dramTierPercent}%)</text>
                    <text x="${60 + (520 * (gpuTierPercent + dramTierPercent / 2)) / 100}" y="384"
                        text-anchor="middle" fill="#fbbf24" font-size="9">${tierStats.dram.storageMB.toFixed(0)} MB</text>

                    <line x1="${60 + (520 * (gpuTierPercent + dramTierPercent + (100 - gpuTierPercent - dramTierPercent) / 2)) / 100}" y1="310"
                        x2="${60 + (520 * (gpuTierPercent + dramTierPercent + (100 - gpuTierPercent - dramTierPercent) / 2)) / 100}" y2="325" stroke="#888" stroke-width="1"/>
                    <text x="${60 + (520 * (gpuTierPercent + dramTierPercent + (100 - gpuTierPercent - dramTierPercent) / 2)) / 100}"
                        y="338" text-anchor="middle" fill="#888" font-size="10">NVMe SSD (${(100 - gpuTierPercent - dramTierPercent).toFixed(0)}%)</text>
                    <text x="${60 + (520 * (gpuTierPercent + dramTierPercent + (100 - gpuTierPercent - dramTierPercent) / 2)) / 100}"
                        y="352" text-anchor="middle" fill="#888" font-size="9">${tierStats.ssd.storageGB.toFixed(2)} GB</text>

                    <!-- Gradients -->
                    <defs>
                        <linearGradient id="zipfGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                            <stop offset="0%" stop-color="#22c55e"/>
                            <stop offset="15%" stop-color="#fbbf24"/>
                            <stop offset="100%" stop-color="#666"/>
                        </linearGradient>
                        <linearGradient id="areaGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                            <stop offset="0%" stop-color="#22c55e"/>
                            <stop offset="15%" stop-color="#fbbf24"/>
                            <stop offset="100%" stop-color="#666"/>
                        </linearGradient>
                    </defs>

                    <!-- Area under curve -->
                    <path
                        d="M 60 300 L 60 ${300 - (zipfData[0]?.frequency || 0) * 50000} ${zipfData
                            .slice(1, 50)
                            .map((d, i) => `L ${60 + (i + 1) * 10.4} ${Math.max(30, 300 - d.frequency * 50000)}`)
                            .join(' ')} L 580 300 Z"
                        fill="url(#areaGradient)"
                        opacity="0.3"/>

                    <!-- Distribution curve -->
                    <path
                        d="M 60 ${300 - (zipfData[0]?.frequency || 0) * 50000} ${zipfData
                            .slice(1, 50)
                            .map((d, i) => `L ${60 + (i + 1) * 10.4} ${Math.max(30, 300 - d.frequency * 50000)}`)
                            .join(' ')}"
                        fill="none"
                        stroke="url(#zipfGradient)"
                        stroke-width="3"/>

                    <!-- Annotations -->
                    <text x="150" y="80" fill="#64ffda" font-size="11">
                        ‚Üê Head: Few N-grams,
                    </text>
                    <text x="170" y="95" fill="#64ffda" font-size="11">
                        massive access share
                    </text>

                    <text x="380" y="250" fill="#888" font-size="11">
                        Long tail: Many N-grams, ‚Üí
                    </text>
                    <text x="400" y="265" fill="#888" font-size="11">
                        rare individual access
                    </text>
                `
            }

            // Render Multi-Head Hashing diagram
            function renderMultihashDiagram() {
                const svg = document.getElementById('multihashDiagram')

                let hashBoxesBigram = ''
                let hashBoxesTrigram = ''
                for (let i = 0; i < 8; i++) {
                    const x = 40 + (i % 4) * 46
                    const y = 210 + Math.floor(i / 4) * 45
                    hashBoxesBigram += `
                        <rect x="${x}" y="${y}" width="40" height="38" rx="4" fill="rgba(244, 114, 182, 0.2)" stroke="#f472b6"/>
                        <text x="${x + 20}" y="${y + 23}" text-anchor="middle" fill="#f472b6" font-size="9">H${i + 1}</text>
                    `
                    const x2 = 230 + (i % 4) * 46
                    hashBoxesTrigram += `
                        <rect x="${x2}" y="${y}" width="40" height="38" rx="4" fill="rgba(124, 58, 237, 0.2)" stroke="#7c3aed"/>
                        <text x="${x2 + 20}" y="${y + 23}" text-anchor="middle" fill="#7c3aed" font-size="9">H${i + 1}</text>
                    `
                }

                svg.innerHTML = `
                    <!-- Arrow markers -->
                    <defs>
                        <marker id="arrowHead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="#666"/>
                        </marker>
                        <marker id="arrowPink" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="#f472b6"/>
                        </marker>
                        <marker id="arrowPurple" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="#7c3aed"/>
                        </marker>
                    </defs>

                    <!-- Input token sequence -->
                    <rect x="50" y="20" width="350" height="45" rx="6" fill="rgba(100, 255, 218, 0.1)" stroke="#64ffda"/>
                    <text x="225" y="38" text-anchor="middle" fill="#64ffda" font-size="11" font-weight="bold">
                        Input: "... the United States of ..."
                    </text>
                    <text x="225" y="55" text-anchor="middle" fill="#888" font-size="10">
                        Current position: "of"
                    </text>

                    <!-- Arrow down -->
                    <path d="M 225 65 L 225 90" stroke="#666" stroke-width="2" marker-end="url(#arrowHead)"/>

                    <!-- N-gram extraction boxes -->
                    <rect x="50" y="95" width="160" height="50" rx="6" fill="rgba(244, 114, 182, 0.15)" stroke="#f472b6"/>
                    <text x="130" y="115" text-anchor="middle" fill="#f472b6" font-size="11" font-weight="bold">2-gram (bigram)</text>
                    <text x="130" y="133" text-anchor="middle" fill="#f472b6" font-size="12">"States of"</text>

                    <rect x="240" y="95" width="160" height="50" rx="6" fill="rgba(124, 58, 237, 0.15)" stroke="#7c3aed"/>
                    <text x="320" y="115" text-anchor="middle" fill="#7c3aed" font-size="11" font-weight="bold">3-gram (trigram)</text>
                    <text x="320" y="133" text-anchor="middle" fill="#7c3aed" font-size="12">"United States of"</text>

                    <!-- Arrows to hash heads -->
                    <path d="M 130 145 L 130 175" stroke="#f472b6" stroke-width="2" marker-end="url(#arrowPink)"/>
                    <path d="M 320 145 L 320 175" stroke="#7c3aed" stroke-width="2" marker-end="url(#arrowPurple)"/>

                    <!-- 8 Hash heads for bigram -->
                    <rect x="30" y="180" width="200" height="130" rx="6" fill="rgba(244, 114, 182, 0.05)" stroke="#f472b6" stroke-dasharray="4,4"/>
                    <text x="130" y="198" text-anchor="middle" fill="#f472b6" font-size="10" font-weight="bold">8 Hash Heads (œÜ‚ÇÇ,‚ÇÅ ... œÜ‚ÇÇ,‚Çà)</text>
                    ${hashBoxesBigram}

                    <!-- 8 Hash heads for trigram -->
                    <rect x="220" y="180" width="200" height="130" rx="6" fill="rgba(124, 58, 237, 0.05)" stroke="#7c3aed" stroke-dasharray="4,4"/>
                    <text x="320" y="198" text-anchor="middle" fill="#7c3aed" font-size="10" font-weight="bold">8 Hash Heads (œÜ‚ÇÉ,‚ÇÅ ... œÜ‚ÇÉ,‚Çà)</text>
                    ${hashBoxesTrigram}

                    <!-- Parallel arrows down -->
                    <text x="225" y="328" text-anchor="middle" fill="#64ffda" font-size="10" font-weight="bold">16 PARALLEL LOOKUPS</text>
                    <path d="M 130 310 L 130 355" stroke="#f472b6" stroke-width="2" stroke-dasharray="3,3"/>
                    <path d="M 320 310 L 320 355" stroke="#7c3aed" stroke-width="2" stroke-dasharray="3,3"/>

                    <!-- Embedding tables -->
                    <rect x="15" y="360" width="200" height="55" rx="6" fill="rgba(34, 197, 94, 0.1)" stroke="#22c55e"/>
                    <text x="115" y="380" text-anchor="middle" fill="#22c55e" font-size="9" font-weight="bold">8 Tables for Bigrams</text>
                    <text x="115" y="395" text-anchor="middle" fill="#22c55e" font-size="8">(E‚ÇÇ,‚ÇÅ ... E‚ÇÇ,‚Çà)</text>
                    <text x="115" y="408" text-anchor="middle" fill="#888" font-size="8">Each: 80-dim vectors</text>

                    <rect x="235" y="360" width="200" height="55" rx="6" fill="rgba(34, 197, 94, 0.1)" stroke="#22c55e"/>
                    <text x="335" y="380" text-anchor="middle" fill="#22c55e" font-size="9" font-weight="bold">8 Tables for Trigrams</text>
                    <text x="335" y="395" text-anchor="middle" fill="#22c55e" font-size="8">(E‚ÇÉ,‚ÇÅ ... E‚ÇÉ,‚Çà)</text>
                    <text x="335" y="408" text-anchor="middle" fill="#888" font-size="8">Each: 80-dim vectors</text>

                    <!-- Concatenation -->
                    <path d="M 115 415 L 115 440 L 225 455" stroke="#22c55e" stroke-width="2"/>
                    <path d="M 335 415 L 335 440 L 225 455" stroke="#22c55e" stroke-width="2"/>

                    <rect x="125" y="460" width="200" height="35" rx="6" fill="rgba(100, 255, 218, 0.2)" stroke="#64ffda" stroke-width="2"/>
                    <text x="225" y="482" text-anchor="middle" fill="#64ffda" font-size="11" font-weight="bold">Concatenate ‚Üí 1280-dim vector</text>
                `
            }

            // Render Log-Log chart
            function renderLogLogChart() {
                const svg = document.getElementById('loglogChart')
                const zipfData = calculateZipfData()

                // Grid lines
                let gridLines = ''
                for (let i = 0; i < 8; i++) {
                    gridLines += `
                        <line x1="${80 + i * 75}" y1="50" x2="${80 + i * 75}" y2="350" stroke="#222" stroke-width="1"/>
                        <line x1="80" y1="${50 + i * 42.8}" x2="680" y2="${50 + i * 42.8}" stroke="#222" stroke-width="1"/>
                    `
                }

                // X-axis ticks
                let xTicks = ''
                for (let i = 0; i < 8; i++) {
                    xTicks += `<text x="${80 + i * 75}" y="368" text-anchor="middle" fill="#666" font-size="10">10<tspan baseline-shift="super" font-size="8">${i}</tspan></text>`
                }

                // Data points
                const points = zipfData
                    .filter((_, i) => i % 2 === 0)
                    .map(
                        (d) =>
                            `<circle cx="${80 + (d.logRank / 7) * 600}" cy="${200 - d.logFreq * 30}" r="4" fill="#64ffda" opacity="0.8"/>`,
                    )
                    .join('')

                svg.innerHTML = `
                    ${gridLines}

                    <!-- Axes -->
                    <line x1="80" y1="350" x2="680" y2="350" stroke="#666" stroke-width="2"/>
                    <line x1="80" y1="350" x2="80" y2="50" stroke="#666" stroke-width="2"/>

                    <!-- Axis labels -->
                    <text x="380" y="390" text-anchor="middle" fill="#888" font-size="12">log‚ÇÅ‚ÇÄ(rank)</text>
                    <text x="30" y="200" text-anchor="middle" fill="#888" font-size="12" transform="rotate(-90, 30, 200)">log‚ÇÅ‚ÇÄ(frequency)</text>

                    <!-- X-axis ticks -->
                    ${xTicks}

                    <!-- The straight line (Zipf's law) -->
                    <line x1="80" y1="${200 - zipfExponent * 0}" x2="680" y2="${200 + zipfExponent * 300}" stroke="#7c3aed" stroke-width="3" stroke-dasharray="10,5"/>

                    <!-- Data points -->
                    ${points}

                    <!-- Slope annotation -->
                    <text x="500" y="120" fill="#7c3aed" font-size="14" font-weight="bold">Slope = -${zipfExponent.toFixed(2)}</text>
                    <text x="500" y="140" fill="#888" font-size="11">(Zipf exponent s)</text>

                    <!-- Formula -->
                    <rect x="80" y="70" width="240" height="50" rx="8" fill="rgba(0,0,0,0.5)" stroke="#7c3aed"/>
                    <text x="200" y="100" text-anchor="middle" fill="#64ffda" font-size="13">log(f) = -s ¬∑ log(r) + C</text>
                `
            }

            // Render exponent cards
            function renderExponentCards() {
                const container = document.getElementById('exponentCards')
                const exponents = [
                    { exp: 0.7, desc: 'Flatter distribution', example: 'More uniform access pattern' },
                    { exp: 1.0, desc: 'Classic Zipf', example: 'Typical natural language (s ‚âà 1.0)' },
                    { exp: 1.3, desc: 'Steeper drop-off', example: 'Even more concentrated at head' },
                ]

                container.innerHTML = exponents
                    .map((item) => {
                        const isActive = Math.abs(zipfExponent - item.exp) < 0.2
                        return `
                        <div style="
                            padding: 1rem;
                            background: ${isActive ? 'rgba(100, 255, 218, 0.1)' : 'rgba(255,255,255,0.02)'};
                            border: 1px solid ${isActive ? '#64ffda' : '#333'};
                            border-radius: 8px;
                        ">
                            <h4 style="color: var(--accent-pink); margin: 0 0 0.5rem 0">s = ${item.exp}</h4>
                            <p style="color: var(--text-secondary); margin: 0; font-size: 0.85rem">${item.desc}</p>
                            <p style="color: var(--text-muted); margin: 0.25rem 0 0 0; font-size: 0.75rem">${item.example}</p>
                        </div>
                    `
                    })
                    .join('')
            }

            // Render Tiers diagram
            function renderTiersDiagram() {
                const svg = document.getElementById('tiersDiagram')
                const tierStats = calculateTierStats()

                svg.innerHTML = `
                    <defs>
                        <marker id="tierArrow" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="#666"/>
                        </marker>
                    </defs>

                    <!-- GPU Tier -->
                    <rect x="50" y="30" width="300" height="90" rx="8" fill="rgba(34, 197, 94, 0.2)" stroke="#22c55e" stroke-width="2"/>
                    <text x="200" y="55" text-anchor="middle" fill="#22c55e" font-size="14" font-weight="bold">GPU HBM</text>
                    <text x="200" y="78" text-anchor="middle" fill="#22c55e" font-size="11">${gpuTierPercent}% of entries (${tierStats.gpu.entries.toLocaleString()})</text>
                    <text x="200" y="100" text-anchor="middle" fill="#64ffda" font-size="16" font-weight="bold">${tierStats.gpu.accessPercent.toFixed(1)}% of accesses</text>
                    <text x="200" y="115" text-anchor="middle" fill="#888" font-size="9">${tierStats.gpu.storageMB.toFixed(0)} MB | ~100ns latency</text>

                    <!-- Arrow -->
                    <path d="M 200 120 L 200 145" stroke="#666" stroke-width="2" marker-end="url(#tierArrow)"/>

                    <!-- DRAM Tier -->
                    <rect x="50" y="150" width="300" height="90" rx="8" fill="rgba(251, 191, 36, 0.2)" stroke="#fbbf24" stroke-width="2"/>
                    <text x="200" y="175" text-anchor="middle" fill="#fbbf24" font-size="14" font-weight="bold">Host DRAM</text>
                    <text x="200" y="198" text-anchor="middle" fill="#fbbf24" font-size="11">${dramTierPercent}% of entries (${tierStats.dram.entries.toLocaleString()})</text>
                    <text x="200" y="220" text-anchor="middle" fill="#64ffda" font-size="16" font-weight="bold">${tierStats.dram.accessPercent.toFixed(1)}% of accesses</text>
                    <text x="200" y="235" text-anchor="middle" fill="#888" font-size="9">${tierStats.dram.storageMB.toFixed(0)} MB | ~100-500ns latency</text>

                    <!-- Arrow -->
                    <path d="M 200 240 L 200 265" stroke="#666" stroke-width="2" marker-end="url(#tierArrow)"/>

                    <!-- SSD Tier -->
                    <rect x="50" y="270" width="300" height="90" rx="8" fill="rgba(100, 100, 100, 0.15)" stroke="#888" stroke-width="2"/>
                    <text x="200" y="295" text-anchor="middle" fill="#888" font-size="14" font-weight="bold">NVMe SSD</text>
                    <text x="200" y="318" text-anchor="middle" fill="#888" font-size="11">${(100 - gpuTierPercent - dramTierPercent).toFixed(1)}% of entries (${tierStats.ssd.entries.toLocaleString()})</text>
                    <text x="200" y="340" text-anchor="middle" fill="#64ffda" font-size="16" font-weight="bold">${tierStats.ssd.accessPercent.toFixed(1)}% of accesses</text>
                    <text x="200" y="355" text-anchor="middle" fill="#888" font-size="9">${tierStats.ssd.storageGB.toFixed(2)} GB | ~10-100Œºs latency</text>
                `
            }

            // Render tier stats
            function renderTierStats() {
                const container = document.getElementById('tierStats')
                const tierStats = calculateTierStats()

                const tiers = [
                    {
                        name: 'GPU HBM',
                        color: '#22c55e',
                        stats: tierStats.gpu,
                        storage: `${tierStats.gpu.storageMB.toFixed(0)} MB`,
                    },
                    {
                        name: 'Host DRAM',
                        color: '#fbbf24',
                        stats: tierStats.dram,
                        storage: `${tierStats.dram.storageMB.toFixed(0)} MB`,
                    },
                    {
                        name: 'NVMe SSD',
                        color: '#888',
                        stats: tierStats.ssd,
                        storage: `${tierStats.ssd.storageGB.toFixed(2)} GB`,
                    },
                ]

                container.innerHTML = tiers
                    .map(
                        (tier) => `
                    <div class="tier-card" style="border: 1px solid ${tier.color}40">
                        <div class="tier-card-header">
                            <h4 style="color: ${tier.color}; margin: 0">${tier.name}</h4>
                            <span class="tier-storage">${tier.storage}</span>
                        </div>
                        <div style="margin-bottom: 0.5rem">
                            <span style="color: var(--text-secondary); font-size: 0.85rem">Access Share: </span>
                            <span style="color: var(--accent-cyan); font-weight: bold">${tier.stats.accessPercent.toFixed(2)}%</span>
                        </div>
                        <div class="tier-progress">
                            <div class="tier-progress-bar" style="width: ${Math.min(tier.stats.accessPercent, 100)}%; background: ${tier.color}"></div>
                        </div>
                    </div>
                `,
                    )
                    .join('')

                // Update Zipf power box
                const zipfPowerBox = document.getElementById('zipfPowerBox')
                zipfPowerBox.innerHTML = `
                    <h4 style="color: var(--accent-cyan); margin: 0 0 0.5rem 0; font-size: 0.9rem">üí° The Power of Zipf</h4>
                    <p style="margin: 0; font-size: 0.85rem; line-height: 1.6">
                        With just <strong>${gpuTierPercent}%</strong> in GPU +
                        <strong>${dramTierPercent}%</strong> in DRAM, you serve
                        <strong style="color: var(--accent-green)">${(tierStats.gpu.accessPercent + tierStats.dram.accessPercent).toFixed(1)}%</strong> of
                        all accesses from fast memory!
                    </p>
                `
            }

            // Render Access Pattern diagram
            function renderAccessPatternDiagram() {
                const svg = document.getElementById('accessPatternDiagram')

                svg.innerHTML = `
                    <defs>
                        <marker id="arrow2" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="#666"/>
                        </marker>
                    </defs>

                    <!-- Input tokens -->
                    <rect x="20" y="20" width="310" height="40" rx="6" fill="rgba(100, 255, 218, 0.1)" stroke="#64ffda"/>
                    <text x="175" y="45" text-anchor="middle" fill="#64ffda" font-size="12">Input: "United States of America"</text>

                    <!-- Arrow down -->
                    <path d="M 175 60 L 175 85" stroke="#666" stroke-width="2" marker-end="url(#arrow2)"/>

                    <!-- N-gram extraction -->
                    <rect x="20" y="90" width="310" height="60" rx="6" fill="rgba(244, 114, 182, 0.1)" stroke="#f472b6"/>
                    <text x="175" y="110" text-anchor="middle" fill="#f472b6" font-size="11" font-weight="bold">Extract N-grams (N=2,3)</text>
                    <text x="175" y="130" text-anchor="middle" fill="#888" font-size="10">"States of", "of America", "States of America"...</text>
                    <text x="175" y="145" text-anchor="middle" fill="#888" font-size="9">+ Tokenizer compression (23% vocab reduction)</text>

                    <!-- Arrow down -->
                    <path d="M 175 150 L 175 175" stroke="#666" stroke-width="2" marker-end="url(#arrow2)"/>

                    <!-- Multi-head hashing -->
                    <rect x="20" y="180" width="310" height="50" rx="6" fill="rgba(124, 58, 237, 0.1)" stroke="#7c3aed"/>
                    <text x="175" y="200" text-anchor="middle" fill="#7c3aed" font-size="11" font-weight="bold">Multi-Head Hashing (8 heads √ó 2 orders)</text>
                    <text x="175" y="220" text-anchor="middle" fill="#888" font-size="10">œÜ(g) ‚Üí 16 deterministic hash IDs per token position</text>

                    <!-- Arrow down -->
                    <path d="M 175 230 L 175 255" stroke="#666" stroke-width="2" marker-end="url(#arrow2)"/>

                    <!-- Lookup -->
                    <rect x="20" y="260" width="310" height="35" rx="6" fill="rgba(34, 197, 94, 0.1)" stroke="#22c55e"/>
                    <text x="175" y="282" text-anchor="middle" fill="#22c55e" font-size="11">16 parallel O(1) lookups ‚Üí embedding vectors</text>
                `
            }

            // Update all visualizations
            function updateAll() {
                renderZipfChart()
                renderLogLogChart()
                renderExponentCards()
                renderTiersDiagram()
                renderTierStats()
            }

            // Initialize
            renderNgramExamples()
            renderZipfChart()
            renderMultihashDiagram()
            renderLogLogChart()
            renderExponentCards()
            renderTiersDiagram()
            renderTierStats()
            renderAccessPatternDiagram()
        </script>
    </body>
</html>
